#!/bin/bash

. GLOBAL

Function="${1}"

barLine() { printf '=%.0s' $(seq 3 "$(tput cols)"); echo; }


rename_backup() {
bak=$(ls -td -- "$BkpDir"/* | head -n 1 )
if [[ "$last_bak" != $bak ]]; then
mv "$bak" "$bak-$1"
fi
}


print_prompt() {
  while (( "$#" )); do
    case "$1" in
      -r) echo -ne "\e[31m$2\e[0m" ;;  # Red
      -g) echo -ne "\e[32m$2\e[0m" ;;  # Green
      -y) echo -ne "\e[33m$2\e[0m" ;;  # Yellow
      -b) echo -ne "\e[34m$2\e[0m" ;;  # Blue
      -m) echo -ne "\e[35m$2\e[0m" ;;  # Magenta
      -c) echo -ne "\e[36m$2\e[0m" ;;  # Cyan
      -w) echo -ne "\e[37m$2\e[0m" ;;  # White
      -n) echo -ne "\e[96m$2\e[0m" ;;  # Neon
      *) echo "Invalid option: $1" ;;
    esac
    shift 2
  done
  echo ""
}

box_me() {
 local sender="Hyprdots-ctl: "
 local color=3

 while (( "$#" )); do
    case "$1" in
      -s)
        sender="$2"
        shift 2
        ;;
      -c)
        color="$2"
        shift 2
        ;;
      *)
        break
        ;;
    esac
 done

  local s="${sender}$*"
  tput setaf ${color}
  echo -e " ═${s//?/═}"
  echo -e "║$s ║"
  echo -e " ═${s//?/═}"
  tput sgr0
}

ask_confirm() {
  local key=$1
  while true; do
    if [ -z "$key" ]; then
    read -n 1 -s -r -p "[ENTER: continue ANY: exit]" key ; [[ -z "$key" ]] && break || exit 0
    else
      read -p "Please type '$(print_prompt -m "$key")' to continue: " answer 
      if [[ "$answer" == "$key" ]]; then
        break
      else
        print_prompt -r "Invalid input, please try again."
      fi
    fi
  done
}

case_help() {
  OPTION="$1"
  sed -n "/case \${$OPTION} in/,/esac/p" "${0}" | grep '#?' | awk -F') #?' '{gsub(/ #?/, "", $1); gsub(/?/, "", $2); printf "%-30s %s\n", $1, $2}'
}

pkg_installed()
{
    local PkgIn=$1

    if pacman -Qi $PkgIn &> /dev/null
    then
        #echo "${PkgIn} is already installed..."
        return 0
    else
        #echo "${PkgIn} is not installed..."
        return 1
    fi
}

CHECK () {
    local Pkg_Dep=$(for PkgIn in "$@"; do ! pkg_installed $PkgIn && echo "$PkgIn"; done)

if [[ -n "${Pkg_Dep}" ]]; then echo -e "$0 Dependencies:\n$Pkg_Dep"
    notify-send -a "${0}" "Confirm to install Dependencies: '${Pkg_Dep}'"
     get_aurhlpr 
    { pkexec env DISPLAY=$DISPLAY XAUTHORITY=$XAUTHORITY "${aurhlpr}" -S $Pkg_Dep --noconfirm && notify-send "Installed: ${Pkg_Dep}" ; } || { notify-send "Operation Cancelled" && exit 1; }
fi
}

do_contain() {
    local etc_file="$1"
    local conf_file="$2"
    local tag_line=$(grep -i "Hyprdots-ctl tag:" "${etc_file}")

    if [[ ! -f "${conf_file}" ]] || grep -qF "${tag_line}" "${conf_file}" ; then
        cp "${etc_file}" "${conf_file}"
        echo "Copied $etc_file to ${conf_file} because it contained '${tag_line}'"
    else :
        # echo "Did not copy ${etc_file} to ${conf_file} because it did not contain '${tag_line}'"
        print_prompt -r "Warning:" -m "File was changed: ${conf_file}" -w "\n Delete file to recieve updates" 
    fi
}

set_branch() {
 git_branch=$(git branch -a | fzf --prompt='Choose a branch')
 if [[ $git_branch == *"*"* ]]; then
    print_prompt -y "Already in branch: ${git_branch}"
    return 1
 else
# Extract the branch name without the remote prefix and trim leading whitespace
branch_name=$(echo "${git_branch}" | sed 's/.*\///' | sed 's/^[[:space:]]*//')
# Switch to the selected branch
git checkout "${branch_name}"
echo "On branch: ${branch_name}"
 fi
}


repo_info() {
print_prompt -g "CloneDirectory: " -n "${CloneDir}"
print_prompt -g "Git URL: " -n "$( git remote get-url origin)"
print_prompt -g "Git Branch: " -n "$(git branch --show-current)"
}


rofi_pos() {

CHECK rofi jq

roFile="~/.config/rofi/clipboard.rasi"
# set position
x_offset=-15   #* Cursor spawn position on clipboard
y_offset=210   #* To point the Cursor to the 1st and 2nd latest word
#!base on $HOME/.config/rofi/clipboard.rasi 
clip_h=$(cat "${XDG_CONFIG_HOME:-$HOME/.config}/rofi/clipboard.rasi" | awk '/window {/,/}/'  | awk '/height:/ {print $2}' | awk -F "%" '{print $1}')
clip_w=$(cat "${XDG_CONFIG_HOME:-$HOME/.config}/rofi/clipboard.rasi" | awk '/window {/,/}/'  | awk '/width:/ {print $2}' | awk -F "%" '{print $1}')
#clip_h=55 #! Modify limits for size of the Clipboard
#clip_w=20 #! This values are transformed per cent(100)
#? Monitor resolution , scale and rotation 
x_mon=$(hyprctl -j monitors | jq '.[] | select(.focused==true) | .width')
y_mon=$(hyprctl -j monitors | jq '.[] | select(.focused==true) | .height')
#? Rotated monitor? 
monitor_rot=$(hyprctl -j monitors | jq '.[] | select(.focused==true) | .transform')
if [ $((monitor_rot %  2)) -eq  1 ]; then  # if rotated 270 deg
 tempmon=$x_mon
    x_mon=$y_mon
    y_mon=$tempmon
    tempclip=$clip_w
    clip_w=$clip_h
    clip_h=$tempclip
#! For rotated monitors
fi
#? Scaled monitor Size
monitor_scale=$(hyprctl -j monitors | jq '.[] | select (.focused == true) | .scale' | sed 's/\.//')
x_mon=$((x_mon * 100 / monitor_scale ))
y_mon=$((y_mon * 100 / monitor_scale))
#? monitor position
x_pos=$(hyprctl -j monitors | jq '.[] | select(.focused==true) | .x')
y_pos=$(hyprctl -j monitors | jq '.[] | select(.focused==true) | .y')
#? cursor position
x_cur=$(hyprctl -j cursorpos | jq '.x')
y_cur=$(hyprctl -j cursorpos | jq '.y')
# Ignore position
 x_cur=$(( x_cur - x_pos))
 y_cur=$(( y_cur - y_pos))
#Limiting
# Multiply before dividing to avoid losing precision due to integer division
clip_w=$(( x_mon*clip_w/100 ))
clip_h=$(( y_mon*clip_h/100 ))
max_x=$((x_mon - clip_w - 5 )) #offset of 5 for gaps
max_y=$((y_mon - clip_h - 15 )) #offset of 15 for gaps

# best for multi monitor
# [ $((monitor_rot %  2)) -eq  1 ] && clip_h=$(( clip_w * 175/100 )) && h_override="height: ${clip_h}px;" 

x_cur=$((x_cur - x_offset))
y_cur=$((y_cur - y_offset))
# 
x_cur=$(( x_cur < min_x ? min_x : ( x_cur > max_x ? max_x :  x_cur)))
y_cur=$(( y_cur < min_y ? min_y : ( y_cur > max_y ? max_y :  y_cur)))

pos="window {location: north west; x-offset: ${x_cur}px; y-offset: ${y_cur}px;}" #! I just Used the old pos function
#pos="window {location: $y_rofi $x_rofi; $x_offset $y_offset}" 

# read hypr theme border
wind_border=$(( hypr_border * 3/2 ))
elem_border=`[ $hypr_border -eq 0 ] && echo "5" || echo $hypr_border`
r_override="window {${h_override}border: ${hypr_width}px; border-radius: ${wind_border}px;} entry {border-radius: ${elem_border}px;} element {border-radius: ${elem_border}px;}"


# read hypr font size

fnt_override=`gsettings get org.gnome.desktop.interface monospace-font-name | awk '{gsub(/'\''/,""); print $NF}'`
fnt_override="configuration {font: \"JetBrainsMono Nerd Font ${fnt_override}\";}"

}




check_Ping() {
  if ! ping -q -c 1 -W 1 8.8.8.8 >/dev/null; then
    box_me "Error: No internet connection."
    exit 1
  fi
}

# if [ ! -f "/tmp/hyprdots_update_check" ] || [[ $(find "/tmp/hyprdots_update_check" -mmin +4320) ]]; then
#     echo "Checking For Updates (This prompts every 3 Days or after you run Hyprdots update)"
#     if ping -q -c 1 -W 1 8.8.8.8 > /dev/null; then 
#         git fetch > /dev/null 2>&1
#         if [ "$(git rev-parse HEAD)" != "$(git rev-parse @{u})" ]; then
#             echo -e "Updates available! \nRUN: \033[0;34mHyprdots update\033[0m"
#         # else
#         #     echo -e "\033[0;32mHyprdots Up to date\033[0m"
#         fi
#     # else
#     #     echo "Please Check your Internet Connectivity"
#     fi
#     touch "/tmp/hyprdots_update_check"
# fi

#??? Handle Syntax errors
help=$(grep -E '^\w+ *\( *\)\s*\{ #\?' "$0" | awk 'BEGIN { FS = "[()#?]" } { printf "  %-20s %s\n", $1, $5 }')
if [ -z "$1" ]; then  box_me -s "Hyprdots-ctl $hyprdots_ctl_version" ; echo "$help" ;exit 1 
elif ! (echo "$help" | awk '{print $1}' | grep -w "$Function" 1> /dev/null); then echo -e "[Function unknown]: '$*'\nUsage: Hyprdots [Function] [Arguments] [Parameter]\n$help" ; exit 1
fi


Parameters() { #TODO: Add conditionals here like 'case'
Function="${Function// /}"
if awk "/^$Function\(\) \{/,/}/" "$0" | grep > /dev/null  'case'; then
  man_params=$(awk "/^$Function\(\) \{/,/esac/" "$0" | grep -E '^\s+\w+\)' | awk 'BEGIN { FS = "[()#?]" } { sub(/^[ \t]+/, "", $1); printf "                          %-15s %s\n","["$1"]", $4 }')
echo "$man_params"
fi
} 

SelectOption() { #! Can be improved soon using other package.:-  Used fzf. 
    echo ""
    IFS=$'\n' read -d '' -ra options < <(echo "$1" | grep -v "^$")
    select selected in "${options[@]}" ; do echo "You selected: $selected" ; break ; done
    #echo "$selected"
}

ConfigCtl() {
    FILE="$1"
    EDITOR="${EDITOR:-code}"  #* Use VS Code as the default editor
    echo -e "[Editor]: $EDITOR (\"export EDITOR=pref_editor\") \n[Modifying]: $FILE \nPress Any Key if done editing"
    #kitty -o allow_remote_control=yes -o listen_on=unix:/tmp/mykitty $(which $EDITOR) "$FILE" > /dev/null 2>&1 &
    kitty "$(which $EDITOR)" "$FILE" > /dev/null 2>&1 &
    LAST_MD5SUM=$(md5sum "$FILE")
    while true; do CURRENT_MD5SUM=$(md5sum "$FILE")
        if [ "$CURRENT_MD5SUM" != "$LAST_MD5SUM" ]; then eval "$ACTION"
            LAST_MD5SUM="$CURRENT_MD5SUM"
        fi ; read -t 2 -n 1 > /dev/null && break #? loop every 2 seconds
    done
}

PreserveCloneDir() { #* Use: Not to mess up the current CloneDir If installing backup.
if [ -f "$HOME"/.config/hypr/scripts/globalcontrol.sh ] ; then
    sed -i "/^CloneDir=/c\CloneDir=\"$CloneDir\"" "$HOME"/.config/hypr/scripts/globalcontrol.sh
fi
}

check_file_change() {
  file=$1
  base=$(echo "$file" | tr '/' '-')
  hash_file="${cacheCtl}/${base}.hash"

  # Calculate the current hash of the file
  current_hash=$(md5sum "$file" | cut -d ' ' -f 1)

  # If the hash file exists, read the stored hash. Otherwise, create it.
  if [ -f "$hash_file" ]; then
    stored_hash=$(cat "$hash_file")
  else
    echo "$current_hash" > "$hash_file"
    stored_hash=$current_hash
  fi

  # Compare the current hash with the stored hash
  if [ "$current_hash" != "$stored_hash" ]; then
    # Update the hash file with the current hash
    echo "$current_hash" > "$hash_file"
    echo " Changes"
    return 1  # Return a non-zero exit status
  else
  echo "Nope"
    return 0  # Return a zero exit status
  fi
}

